from flask import Blueprint, jsonify, request, current_app
from {{ service_name }}.models import *
from db import db

# Создаем внутренний API для межсервисного общения
api_bp = Blueprint('internal_api', __name__)

def get_model_by_name(model_name):
    # Ищем класс модели в глобальном пространстве имен текущего модуля
    # Это работает, так как мы сделали import * from models выше
    return globals().get(model_name)

@api_bp.route('/<model_name>/<int:id>', methods=['GET'])
def get_entity(model_name, id):
    """
    Универсальный эндпоинт: http://service:5000/internal/User/1
    Возвращает JSON представление объекта.
    """
    model = get_model_by_name(model_name)
    if not model:
        return jsonify({"error": f"Model {model_name} not found"}), 404
    
    entity = model.query.get(id)
    if not entity:
        return jsonify({"error": "Not found"}), 404
    
    # Простая сериализация данных модели в словарь
    data = {}
    for column in entity.__table__.columns:
        data[column.name] = getattr(entity, column.name)
        
    return jsonify(data)

@api_bp.route('/<model_name>/update/<int:id>', methods=['POST'])
def update_entity(model_name, id):
    """
    Эндпоинт для изменения данных (например, списания товара)
    Принимает JSON с полями, которые нужно обновить.
    """
    model = get_model_by_name(model_name)
    if not model:
        return jsonify({"error": "Model not found"}), 404
        
    entity = model.query.get(id)
    if not entity:
        return jsonify({"error": "Not found"}), 404

    data = request.json
    for key, value in data.items():
        # Обновляем только те атрибуты, которые существуют у модели
        if hasattr(entity, key):
            setattr(entity, key, value)
    
    db.session.commit()
    return jsonify({"status": "updated"})